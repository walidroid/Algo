<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmes Usuels - Interactive</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        html, body {
            overflow-y: auto;
            min-height: 100%;
            margin: 0;
            padding: 0;
            scroll-behavior: smooth;
        }
        
        .transition-all {
            transition: all 0.3s ease-in-out;
        }
        
        .card {
            background: white;
            height: 100%;
            min-height: 160px; /* Increased minimum height for cards */
            border-radius: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-20px);
            box-shadow: 0 18px 12px rgba(0, 0, 0, 0.15);
        }

        select, input, button {
            transition: all 0.2s ease;
        }

        button:hover {
            transform: translateY(-1px);
        }

        .gradient-bg {
            background: linear-gradient(135deg, #000000 30%, #201dc0 100%);
        }

        .pseudo-code {
            background: #f8fafc;
            border-left: 4px solid #3b82f6;
            font-family: 'Courier New', monospace;
        }

        .execution-step {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 0.375rem;
            background: #f8fafc;
            border-left: 3px solid #3b82f6;
        }
        
        /* Modal animations */
        .modal-open {
            overflow: hidden;
        }
        
        body:not(.modal-open) {
            overflow-y: auto !important;
        }
        
        /* Prevent hover animation on cards in modal */
        #modal-algorithm-info.card:hover,
        #modal-interactive-section.card:hover,
        #modal-results-section.card:hover {
            transform: none;
        }
        
        /* Custom scrollbar styles */
        .overflow-y-auto::-webkit-scrollbar,
        html::-webkit-scrollbar,
        body::-webkit-scrollbar {
            width: 8px;
        }
        
        .overflow-y-auto::-webkit-scrollbar-track,
        html::-webkit-scrollbar-track,
        body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 8px;
        }
        
        .overflow-y-auto::-webkit-scrollbar-thumb,
        html::-webkit-scrollbar-thumb,
        body::-webkit-scrollbar-thumb {
            background: #c5c5c5;
            border-radius: 8px;
        }
        
        .overflow-y-auto::-webkit-scrollbar-thumb:hover,
        html::-webkit-scrollbar-thumb:hover,
        body::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }
        
        /* Results section scrollbar styles */
        #execution-steps::-webkit-scrollbar,
        #modal-execution-steps::-webkit-scrollbar,
        #result-content::-webkit-scrollbar,
        #modal-result-content::-webkit-scrollbar {
            width: 8px;
        }
        
        #execution-steps::-webkit-scrollbar-track,
        #modal-execution-steps::-webkit-scrollbar-track,
        #result-content::-webkit-scrollbar-track,
        #modal-result-content::-webkit-scrollbar-track {
            background: #f8fafc;
            border-radius: 8px;
        }
        
        #execution-steps::-webkit-scrollbar-thumb,
        #modal-execution-steps::-webkit-scrollbar-thumb,
        #result-content::-webkit-scrollbar-thumb,
        #modal-result-content::-webkit-scrollbar-thumb {
            background: #045024;
            border-radius: 8px;
        }
        
        #execution-steps::-webkit-scrollbar-thumb:hover,
        #modal-execution-steps::-webkit-scrollbar-thumb:hover,
        #result-content::-webkit-scrollbar-thumb:hover,
        #modal-result-content::-webkit-scrollbar-thumb:hover {
            background: #2563eb;
        }
        
        /* Fix for scrolling issues */
        #execution-steps, #modal-execution-steps {
            overflow-y: auto !important;
            max-height: 400px !important;
            display: block !important;
            position: relative !important;
            z-index: 10;
        }
        
        /* Ensure full page is scrollable */
        main.container {
            overflow: visible;
            height: auto;
        }
        
        /* Search animation */
        @keyframes highlight {
            0% { background-color: rgba(59, 130, 246, 0.2); }
            100% { background-color: transparent; }
        }
        
        .highlight-animation {
            animation: highlight 1.5s;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <header class="gradient-bg text-white shadow-lg">
        <div class="container mx-auto p-6 flex items-center justify-between">
            <div class="flex items-center">
            <img src="img/logo.webp" alt="Logo" class="h-50 w-50 mr-4">
            <div>
                <h1 class="text-5xl p-4 text-center font-bold from-red-100 via-yellow-600 to-yellow-600 bg-gradient-to-r bg-clip-text text-transparent">Algorithmes Usuels</h1>
                <p class="text-xl opacity-90">Application interactive pour visualiser et tester les algorithmes</p>
            </div>
            </div>
            <a href="videos.html" class="flex items-center text-white hover:text-blue-100 transition">
                <svg class="h-20 w-20 mr-4"  viewBox="0 -198 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <path d="M159.889142,17.9305215 C157.980727,10.8778981 152.47152,5.36869078 145.418897,3.46027607 C132.731218,0 81.6659313,0 81.6659313,0 C81.6659313,0 30.600645,0.104856851 17.9129661,3.56513292 C10.8603427,5.47354763 5.35113537,10.9827549 3.44272066,18.0353783 C-0.395040075,40.5796012 -1.88400735,74.9307055 3.54757751,96.5731595 C5.45599222,103.625783 10.9651995,109.13499 18.0178229,111.043405 C30.7055018,114.503681 81.7707881,114.503681 81.7707881,114.503681 C81.7707881,114.503681 132.836074,114.503681 145.523753,111.043405 C152.576377,109.13499 158.085584,103.625783 159.993999,96.5731595 C164.041473,73.9974796 165.28927,39.6673466 159.889142,17.9305215 Z" fill="#FF0000"> </path> <polygon fill="#FFFFFF" points="65.4131194 81.7883436 107.775287 57.2518405 65.4131194 32.7153374"> </polygon> </g> <path d="M491.23679,33.2396217 C496.794203,33.2396217 500.988477,34.2881902 503.924469,36.2804703 C506.860461,38.2727505 508.957598,41.418456 510.21588,45.7175869 C511.474162,50.0167178 511.998447,55.8887014 511.998447,63.4383947 L511.998447,75.7066462 L485.050236,75.7066462 L485.050236,79.4814928 L485.469663,89.8623211 C485.784234,92.1691718 486.308518,93.8468814 487.147373,94.8954499 C487.986228,95.9440184 489.349367,96.4683027 491.131933,96.4683027 C493.543641,96.4683027 495.221351,95.524591 496.060205,93.6371677 C497.003917,91.7497444 497.423344,88.6040389 497.528201,84.304908 L511.474162,85.1437628 C511.579019,85.7729039 511.579019,86.6117587 511.579019,87.6603272 C511.579019,94.2663088 509.796453,99.1945808 506.126463,102.445143 C502.456473,105.695706 497.423344,107.373415 490.817363,107.373415 C482.848242,107.373415 477.290829,104.856851 474.145124,99.9285787 C470.999418,95.0003067 469.321708,87.2408998 469.321708,76.8600716 L469.321708,64.1723926 C469.678222,46.346728 472.813442,33.2920501 491.23679,33.2396217 Z M297.356473,34.6027607 L297.356473,87.1360429 C297.356473,90.2817485 297.671044,92.5885992 298.405042,93.9517382 C299.894009,96.8667587 303.752741,96.1222751 305.849878,94.6857362 C307.060626,93.8673257 308.03656,92.7468087 308.681013,91.4351738 L308.681013,34.6027607 L324.724111,34.6027607 L324.724111,106.21999 L312.141289,106.21999 L310.77815,97.4120143 L310.46358,97.4120143 C307.003303,104.017996 301.865318,107.373415 295.049623,107.373415 C284.559219,107.346677 281.993214,99.7894861 281.382173,92.1137327 L281.34221,91.5718144 C281.262321,90.3976499 281.224876,89.2247914 281.208518,88.0797546 L281.208518,34.6027607 L297.356473,34.6027607 Z M380.088528,34.6027607 L380.088528,87.1360429 C380.088528,90.2817485 380.403099,92.5885992 381.137097,93.9517382 C382.626064,96.8667587 386.484796,96.1222751 388.581933,94.6857362 C389.792681,93.8673257 390.768615,92.7468087 391.413068,91.4351738 L391.413068,34.6027607 L407.456166,34.6027607 L407.456166,106.21999 L394.873344,106.21999 L393.510205,97.4120143 L393.195635,97.4120143 C389.735359,104.017996 384.597373,107.373415 377.781678,107.373415 C367.291274,107.346677 364.72527,99.7894861 364.114228,92.1137327 L364.074265,91.5718144 C363.994377,90.3976499 363.956931,89.2247914 363.940573,88.0797546 L363.940573,34.6027607 L380.088528,34.6027607 Z M250.800032,33.2396217 C256.042874,33.2396217 260.342005,34.2881902 263.48771,36.490184 C266.633416,38.6921779 269.045124,42.0475971 270.513119,46.6612986 C271.981115,51.275 272.715113,57.4615542 272.715113,65.1161043 L272.715113,75.4969325 C272.715113,83.1514826 271.981115,89.23318 270.513119,93.8468814 C269.045124,98.4605828 266.738273,101.816002 263.48771,104.017996 C260.237148,106.115133 255.83316,107.268558 250.380604,107.268558 C244.718334,107.373415 240.314346,106.21999 237.063784,104.122853 C233.813222,101.920859 231.506371,98.5654397 230.143232,93.9517382 C228.780093,89.3380368 228.150952,83.2563395 228.150952,75.6017894 L228.150952,65.2209611 C228.150952,57.566411 228.88495,51.275 230.457802,46.6612986 C232.030655,41.9427403 234.442363,38.5873211 237.797782,36.490184 C241.153201,34.393047 245.452332,33.2396217 250.800032,33.2396217 Z M432.621811,4.50884458 L432.621811,42.2573108 L432.726667,42.2573108 C434.194663,39.5310327 436.082087,37.3290389 438.703508,35.6513292 C441.151777,34.0047112 444.036719,33.1282731 446.987199,33.1347648 C450.866903,33.1347648 453.802894,34.1833333 456.004888,36.1756135 C458.206882,38.2727505 459.779735,41.5233129 460.723447,46.0321575 C461.637667,50.4001007 462.158265,56.4409407 462.18991,64.059347 L462.191443,64.8015337 L462.191443,76.1260736 C462.191443,86.7166155 460.828303,94.5808793 458.311739,99.6140082 C455.690318,104.647137 451.705757,107.163701 446.253201,107.163701 C443.212353,107.163701 440.486074,106.429703 437.96951,105.066564 C435.742056,103.768558 433.897942,101.908197 432.619841,99.6750483 L432.412097,99.2994376 L432.097526,99.2994376 L430.419817,106.115133 L417.102997,106.115133 L417.102997,4.50884458 L432.621811,4.50884458 Z M368.449418,8.17883436 L368.449418,21.1810838 L352.511177,21.1810838 L352.511177,106.21999 L336.782649,106.21999 L336.782649,21.1810838 L320.739551,21.1810838 L320.739551,8.17883436 L368.449418,8.17883436 Z M195.540471,8.17883436 L195.549368,8.21831506 C195.702992,8.90029808 197.823461,18.3253965 200.15457,29.3057636 L200.33901,30.1757348 C200.431417,30.6122051 200.52408,31.0508039 200.616892,31.4910893 L200.80268,32.3737779 C200.833667,32.5212237 200.864663,32.6688243 200.895663,32.8165631 L201.081684,33.7045241 C201.112686,33.8527505 201.143684,34.0010824 201.174675,34.1495034 L201.360496,35.0409685 L201.360496,35.0409685 L201.630891,36.3438432 C203.204721,43.9476033 204.707581,51.573842 205.606729,57.0421268 L206.026156,57.0421268 C206.888169,52.1367136 208.138966,45.8595566 209.473227,39.4509076 L209.822988,37.7769188 C209.998614,36.9392485 210.175209,36.1011759 210.352094,35.2654533 L210.627389,33.9677196 C213.194244,21.8944685 215.74837,10.6155298 216.223526,8.52432128 L216.254224,8.38927119 C216.285747,8.2506583 216.302128,8.17883436 216.302128,8.17883436 L232.345226,8.17883436 L213.785563,74.3435072 L213.785563,106.115133 L197.952179,106.115133 L197.952179,74.448364 L197.847322,74.448364 L179.497373,8.17883436 L195.540471,8.17883436 Z M250.485461,44.3544479 C248.283467,44.3544479 246.815471,45.5078732 245.87176,47.9195808 C244.928048,50.3312883 244.50862,54.0012781 244.50862,59.1392638 L244.50862,81.473773 C244.50862,86.7166155 244.928048,90.596319 245.766903,92.9031697 C246.605757,95.2100204 248.17861,96.3634458 250.485461,96.3634458 C252.687455,96.3634458 254.260308,95.2100204 255.204019,92.9031697 C256.147731,90.596319 256.567158,86.7166155 256.567158,81.473773 L256.567158,59.1392638 C256.567158,54.0012781 256.147731,50.2264315 255.204019,47.9195808 C254.260308,45.5078732 252.687455,44.3544479 250.485461,44.3544479 Z M435.452946,46.4515849 C434.175003,47.6312244 433.265697,49.087342 432.725029,50.906337 L432.621811,51.275 L432.621811,91.9594581 C433.922036,94.1614519 435.767516,95.6294479 439.018079,95.7343047 C440.695788,95.7343047 442.058927,95.1051636 443.107496,93.8468814 C444.156064,92.5885992 444.890062,90.4914622 445.30949,87.5554703 C445.71214,84.7369182 445.921518,80.8553692 445.937624,75.9108235 L445.938631,75.2872188 L445.938631,65.9549591 C445.938631,60.2926892 445.728917,55.9935583 445.414346,52.9527096 C444.994919,49.9118609 444.470635,47.7098671 443.526923,46.4515849 C441.702414,43.8301636 437.759796,43.8616207 435.452946,46.4515849 Z M490.92222,44.0398773 C489.139653,44.1447342 487.881371,44.6690184 487.147373,45.6127301 C486.308518,46.6612986 485.784234,48.2341513 485.469663,50.541002 C485.161384,52.8017157 485.054514,60.7018825 485.050363,61.0169849 L485.050236,66.1646728 L496.794203,66.1646728 L496.793373,61.6248446 L496.793236,61.7122499 C496.787382,63.2993708 496.754477,60.7909373 496.681842,57.7119157 L496.671921,57.2983077 C496.605889,54.5919004 496.509592,51.574591 496.374776,50.541002 C496.060205,48.1292945 495.535921,46.4515849 494.697066,45.5078732 C493.858211,44.5641616 492.599929,44.0398773 490.92222,44.0398773 Z" fill="#282828"> </path> </g> </g></svg>
                
            </a>
        </div>
    </header>

    <!-- Modal overlay -->
    <div id="algorithm-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center transition-opacity duration-300 opacity-0">
        <div class="bg-white rounded-xl shadow-2xl w-11/12 max-w-6xl max-h-screen sm:max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center p-4 border-b">
                <h2 id="modal-title" class="text-2xl font-bold text-gray-800"></h2>
                <button id="close-modal" class="text-gray-500 hover:text-gray-800 focus:outline-none p-2 rounded-full hover:bg-gray-100 transition-all">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto flex-grow">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div id="modal-algorithm-info" class="card p-6 overflow-y-auto max-h-[50vh] lg:max-h-[55vh]"></div>
                    <div id="modal-interactive-section" class="card p-6 overflow-y-auto max-h-[50vh] lg:max-h-[55vh]"></div>
                </div>
                <div id="modal-results-section" class="card p-6 mt-6 hidden overflow-y-auto max-h-[50vh]">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Résultats</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <div id="modal-result-content" class="bg-blue-50 p-4 rounded-lg text-blue-800 max-h-[400px] overflow-y-auto"></div>
                        </div>
                        <div id="modal-step-by-step">
                            <h3 class="font-bold mb-3 text-gray-800">Étapes d'exécution:</h3>
                            <div id="modal-execution-steps" class="space-y-2 max-h-[400px] overflow-y-auto pr-2">
                                <!-- Steps will be added here dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <main class="container mx-auto p-6">
        <!-- Algorithm Selection -->
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Sélectionnez un algorithme :</h2>
            
            <!-- Search input -->
            <div class="mb-4">
                <div class="relative">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input id="search-algorithms" type="text" placeholder="Rechercher un algorithme..." 
                           class="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div id="search-stats" class="text-sm text-gray-500 mt-2 hidden">
                    <span id="result-count">0</span> résultat(s) trouvé(s)
                </div>
            </div>
            
            <div id="filter-tabs" class="flex flex-wrap space-x-2 mb-4">
                <button class="category-filter active px-3 py-1 bg-blue-100 text-blue-800 rounded-full hover:bg-blue-200 transition" data-category="tous">Tous</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Tri">Tri</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Tableau">Tableau</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Arithmétique">Arithmétique</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Saisie">Saisie</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Affichage">Affichage</button>
                <button class="category-filter px-3 py-1 bg-gray-100 text-gray-800 rounded-full hover:bg-gray-200 transition" data-category="Vérification">Vérification</button>
            </div>
            
            <div id="algorithm-cards" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                <!-- Cards will be dynamically generated here -->
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Algorithm Information -->
            <div id="algorithm-info" class="hidden card p-6">
                <h2 id="algo-title" class="text-2xl font-bold mb-4 text-gray-800">Algorithme</h2>
                <div class="pseudo-code p-4 rounded-lg mb-4">
                    <pre id="algo-pseudocode" class="whitespace-pre-wrap text-sm"></pre>
                </div>
                <p id="algo-description" class="text-gray-600 mb-4"></p>
            </div>

            <!-- Interactive Section -->
            <div id="interactive-section" class="hidden card p-6">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Section Interactive</h2>
                
                <!-- Tableau Input Section -->
                <div id="tableau-input" class="hidden space-y-4">
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Taille du tableau:</label>
                        <input type="number" id="array-size" min="1" max="20" value="5" 
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <div class="flex space-x-2 mt-2">
                            <button id="generate-array" 
                                    class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                                Générer un tableau
                            </button>
                            <button id="random-fill" 
                                    class="flex-1 bg-yellow-500 text-white py-2 px-4 rounded-lg hover:bg-yellow-600 focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2">
                                Valeurs aléatoires
                            </button>
                        </div>
                    </div>
                    <div id="array-elements" class="hidden space-y-2">
                        <!-- Array elements will be added here dynamically -->
                    </div>
                </div>
                
                <!-- Number Input Section -->
                <div id="number-input" class="hidden space-y-4">
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Entrez un nombre:</label>
                        <input type="number" id="input-number" 
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
                
                <!-- Two Numbers Input Section -->
                <div id="two-numbers-input" class="hidden space-y-4">
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Premier nombre:</label>
                        <input type="number" id="first-number" 
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Deuxième nombre:</label>
                        <input type="number" id="second-number" 
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
                
                <!-- Search Input Section -->
                <div id="search-input" class="hidden space-y-4">
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Valeur à rechercher:</label>
                        <input type="number" id="search-value" 
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>

                <button id="execute-button" 
                        class="mt-6 w-full bg-green-500 text-white py-3 px-6 rounded-lg hover:bg-green-600 focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                    Exécuter
                </button>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-section" class="hidden card p-6 mt-6">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Résultats</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <div id="result-content" class="bg-blue-50 p-4 rounded-lg text-blue-800 max-h-[400px] overflow-y-auto"></div>
                </div>
                <div id="step-by-step">
                    <h3 class="font-bold mb-3 text-gray-800">Étapes d'exécution:</h3>
                    <div id="execution-steps" class="space-y-2 max-h-[400px] overflow-y-auto pr-2">
                        <!-- Steps will be added here dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="gradient-bg text-white p-6 mt-12">
        <div class="container mx-auto text-center">
            <p class="opacity-90">© 2025 - Application interactive des Algorithmes Usuels</p>
        </div>
    </footer>

    <script>
// DOM elements
const algorithmSelector = document.getElementById('algorithm-selector');
const algorithmCards = document.getElementById('algorithm-cards');
const algorithmInfo = document.getElementById('algorithm-info');
const algoTitle = document.getElementById('algo-title');
const algoPseudocode = document.getElementById('algo-pseudocode');
const algoDescription = document.getElementById('algo-description');
const interactiveSection = document.getElementById('interactive-section');
const tableauInput = document.getElementById('tableau-input');
const numberInput = document.getElementById('number-input');
const twoNumbersInput = document.getElementById('two-numbers-input');
const searchInput = document.getElementById('search-input');
const arraySize = document.getElementById('array-size');
const generateArray = document.getElementById('generate-array');
const arrayElements = document.getElementById('array-elements');
const executeButton = document.getElementById('execute-button');
const resultsSection = document.getElementById('results-section');
const resultContent = document.getElementById('result-content');
const executionSteps = document.getElementById('execution-steps');

// Global variable to store algorithms
let algorithms = {};

// Fetch algorithm data from algo.json
async function fetchAlgorithms() {
    try {
        const response = await fetch('algo.json');
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        algorithms = await response.json();
        generateAlgorithmCards();
    } catch (error) {
        console.error('There was a problem with the fetch operation:', error);
    }
}

// Generate algorithm cards
function generateAlgorithmCards() {
    // Clear existing cards
    algorithmCards.innerHTML = '';

    // Generate a card for each algorithm
    Object.entries(algorithms).forEach(([key, algo]) => {
        const cardType = getAlgoTypeTag(key);
        const cardColors = getCardColors(cardType);

        const card = document.createElement('div');
        // Add algorithm-specific background class and remove bg from cardColors
        card.className = `card cursor-pointer border ${cardColors.border} rounded-lg hover:shadow-md ${cardColors.hoverBorder} transform hover:-translate-y-1 transition-all duration-200 ${key}-bg`;
        card.dataset.algo = key;
        card.dataset.type = cardType;

        // Create card content
        card.innerHTML = `
            <div class="m-3 flex flex-col h-full">
                <h3 class="text-lg font-semibold mb-2 ${cardColors.title}">${algo.title}</h3>
                <p class="font-light text-sm ${cardColors.text} line-clamp-2 flex-grow">${algo.description}</p>
                <div class="mt-3 text-right">
                    <span class="text-sm ${cardColors.tagText} font-mono ${cardColors.tagBg} inline-block rounded-full px-2 py-1">${cardType}</span>
                </div>
            </div>
        `;

        // Add click event
        card.addEventListener('click', function() {
            // Remove active class from all cards
            document.querySelectorAll('#algorithm-cards .card').forEach(c => {
                const type = c.dataset.type;
                const colors = getCardColors(type);
                c.classList.remove(colors.activeBorder);
                c.style.boxShadow = '';
            });

            // Add active class to clicked card
            this.classList.add(cardColors.activeBorder);
            // Add a glowing effect to the active card
            this.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.2)';

            // Open the modal with this algorithm
            openAlgorithmModal(this.dataset.algo);
        });

        algorithmCards.appendChild(card);
    });
}

// Helper function to get algorithm type tag
function getAlgoTypeTag(algoKey) {
    if (['tri_selection', 'tri_insertion', 'tri_bulle'].includes(algoKey)) {
        return 'Tri';
    } else if (['recherche', 'maximum', 'somme', 'nbocc', 'inverse','tableau'].includes(algoKey)) {
        return 'Tableau';
    } else if (['pgcd', 'ppcm', 'sommediv', 'nbdiv', 'sommechiffre'].includes(algoKey)) {
        return 'Arithmétique';
    } else if (['saisir_controle', 'remplir_simple', 'remplir_positif', 'remplir_aleatoire',
               'remplir_lettres', 'remplir_ordre', 'remplir_deuxchiffres', 'remplir_distinct',
               'remplir_lettresonly'].includes(algoKey)) {
        return 'Saisie';
    } else if (['affichage', 'affichage_pairs', 'extraire', 'insertion'].includes(algoKey)) {
        return 'Affichage';
    } else if (['verif_lettres'].includes(algoKey)) {
        return 'Vérification';
    } else {
        return 'Autre';
    }
}

// Helper function to get card colors based on algorithm type
function getCardColors(type) {
    switch(type) {
        case 'Tri':
            return {
                border: 'border-purple-300',
                hoverBorder: 'hover:border-purple-500',
                activeBorder: 'border-purple-500',
                activeBg: 'bg-purple-100',
                title: 'text-purple-800',
                text: 'text-purple-700',
                tagBg: 'bg-purple-100',
                tagText: 'text-purple-800'
            };
        case 'Tableau':
            return {
                border: 'border-blue-300',
                hoverBorder: 'hover:border-blue-500',
                activeBorder: 'border-blue-500',
                activeBg: 'bg-blue-100',
                title: 'text-blue-800',
                text: 'text-blue-700',
                tagBg: 'bg-blue-100',
                tagText: 'text-blue-800'
            };
        case 'Arithmétique':
            return {
                border: 'border-green-300',
                hoverBorder: 'hover:border-green-500',
                activeBorder: 'border-green-500',
                activeBg: 'bg-green-100',
                title: 'text-green-800',
                text: 'text-green-700',
                tagBg: 'bg-green-100',
                tagText: 'text-green-800'
            };
        case 'Saisie':
            return {
                border: 'border-orange-300',
                hoverBorder: 'hover:border-orange-500',
                activeBorder: 'border-orange-500',
                activeBg: 'bg-orange-100',
                title: 'text-orange-800',
                text: 'text-orange-700',
                tagBg: 'bg-orange-100',
                tagText: 'text-orange-800'
            };
        case 'Affichage':
            return {
                border: 'border-red-300',
                hoverBorder: 'hover:border-red-500',
                activeBorder: 'border-red-500',
                activeBg: 'bg-red-100',
                title: 'text-red-800',
                text: 'text-red-700',
                tagBg: 'bg-red-100',
                tagText: 'text-red-800'
            };
        case 'Vérification':
            return {
                border: 'border-indigo-300',
                hoverBorder: 'hover:border-indigo-500',
                activeBorder: 'border-indigo-500',
                activeBg: 'bg-indigo-100',
                title: 'text-indigo-800',
                text: 'text-indigo-700',
                tagBg: 'bg-indigo-100',
                tagText: 'text-indigo-800'
            };
        default:
            return {
                border: 'border-amber-300',
                hoverBorder: 'hover:border-amber-500',
                activeBorder: 'border-amber-500',
                activeBg: 'bg-amber-100',
                title: 'text-amber-800',
                text: 'text-amber-700',
                tagBg: 'bg-amber-100',
                tagText: 'text-amber-800'
            };
    }
}

// Event listeners
function setupEventListeners() {
    generateArray.addEventListener('click', createArrayInputs);
    executeButton.addEventListener('click', executeAlgorithm);

    // Add random fill button if not already added
    if (!document.getElementById('random-fill')) {
        const generateArrayDiv = document.querySelector('#generate-array').parentNode;
        const randomFillButton = document.createElement('button');
        randomFillButton.id = 'random-fill';
        randomFillButton.className = 'flex-1 bg-yellow-500 text-white py-2 px-4 rounded-lg hover:bg-yellow-600 focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2';
        randomFillButton.textContent = 'Valeurs aléatoires';
        randomFillButton.addEventListener('click', function() {
            createArrayInputs();
            fillRandomArray();
        });
        generateArrayDiv.appendChild(randomFillButton);
    }

    // Add search functionality
    const searchInput = document.getElementById('search-algorithms');
    const searchStats = document.getElementById('search-stats');
    const resultCount = document.getElementById('result-count');

    searchInput.addEventListener('input', function() {
        const query = this.value.toLowerCase();
        const cards = document.querySelectorAll('#algorithm-cards .card');
        let matchCount = 0;

        // Get current active category with fallback to 'tous'
        const activeFilter = document.querySelector('.category-filter.active');
        const activeCategory = activeFilter ? activeFilter.dataset.category : 'tous';

        cards.forEach(card => {
            const algoKey = card.dataset.algo;
            const algo = algorithms[algoKey];
            const title = algo.title.toLowerCase();
            const description = algo.description.toLowerCase();
            const cardType = card.dataset.type;

            // Check if card matches both search query and active category filter
            const matchesSearch = title.includes(query) || description.includes(query) || algoKey.includes(query);
            const matchesCategory = activeCategory === 'tous' || cardType === activeCategory;

            if (matchesSearch && matchesCategory) {
                card.classList.remove('hidden');
                // Add highlight animation
                card.classList.add('highlight-animation');
                setTimeout(() => {
                    card.classList.remove('highlight-animation');
                }, 1500);
                matchCount++;
            } else {
                card.classList.add('hidden');
            }
        });

        // Update search stats
        resultCount.textContent = matchCount;
        if (query) {
            searchStats.classList.remove('hidden');
        } else {
            searchStats.classList.add('hidden');
        }
    });

    // Add category filter functionality
    const filterButtons = document.querySelectorAll('.category-filter');

    filterButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            filterButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.classList.remove('bg-blue-100', 'text-blue-800');
                btn.classList.add('bg-gray-100', 'text-gray-800');
            });

            // Add active class to clicked button
            this.classList.add('active');
            this.classList.remove('bg-gray-100', 'text-gray-800');
            this.classList.add('bg-blue-100', 'text-blue-800');

            const category = this.dataset.category;
            const cards = document.querySelectorAll('#algorithm-cards .card');

            cards.forEach(card => {
                if (category === 'tous' || card.dataset.type === category) {
                    card.classList.remove('hidden');
                } else {
                    card.classList.add('hidden');
                }
            });

            // Reset search when filter changes
            document.getElementById('search-algorithms').value = '';
            document.getElementById('search-stats').classList.add('hidden');
        });
    });
}

// Functions
function showAlgorithmInfo(algoKey) {
    if (!algoKey || !algorithms[algoKey]) {
        algorithmInfo.classList.add('hidden');
        interactiveSection.classList.add('hidden');
        resultsSection.classList.add('hidden');
        return;
    }

    const algo = algorithms[algoKey];

    // Update algorithm info with fade effect
    algorithmInfo.style.opacity = '0';
    algorithmInfo.classList.remove('hidden');

    // Update content
    algoTitle.textContent = algo.title;
    algoPseudocode.textContent = algo.pseudocode;
    algoDescription.textContent = algo.description;

    // Fade in
    setTimeout(() => {
        algorithmInfo.style.transition = 'opacity 0.3s ease-in-out';
        algorithmInfo.style.opacity = '1';
    }, 0);

    // Show interactive section with fade effect
    interactiveSection.style.opacity = '0';
    interactiveSection.classList.remove('hidden');
    setupInteractiveSection(algoKey);
    setTimeout(() => {
        interactiveSection.style.transition = 'opacity 0.3s ease-in-out';
        interactiveSection.style.opacity = '1';
    }, 0);

    // Hide results
    resultsSection.classList.add('hidden');
}

function setupInteractiveSection(algoType) {
    // Hide all input sections first
    tableauInput.classList.add('hidden');
    numberInput.classList.add('hidden');
    twoNumbersInput.classList.add('hidden');
    searchInput.classList.add('hidden');
    arrayElements.classList.add('hidden');

    // Show appropriate inputs based on algorithm type
    switch(algoType) {
        // Array inputs
        case 'remplir':
        case 'maximum':
        case 'somme':
        case 'tri_selection':
        case 'tri_insertion':
        case 'tri_bulle':
        case 'remplir_simple':
        case 'remplir_positif':
        case 'remplir_aleatoire':
        case 'remplir_lettres':
        case 'remplir_ordre':
        case 'remplir_deuxchiffres':
        case 'remplir_distinct':
        case 'remplir_lettresonly':
        case 'affichage':
        case 'affichage_pairs':
        case 'extraire':
            tableauInput.classList.remove('hidden');
            break;

        // Array with search
        case 'recherche':
        case 'nbocc':
        case 'recherche_sequentielle':
        case 'recherche_dichotomique':
            tableauInput.classList.remove('hidden');
            searchInput.classList.remove('hidden');
            break;

        // Single number input
        case 'sommediv':
        case 'nbdiv':
        case 'sommechiffre':
        case 'saisir_controle':
            numberInput.classList.remove('hidden');
            break;

        // String input for string operations
        case 'inverse':
        case 'verif_lettres':
            // Reuse the number input field but change the label
            document.querySelector('#number-input label').textContent = "Entrez une chaîne:";
            document.getElementById('input-number').type = "text";
            numberInput.classList.remove('hidden');
            break;

        // Two numbers input
        case 'pgcd':
        case 'ppcm':
            twoNumbersInput.classList.remove('hidden');
            break;

        // Insertion needs array + position + value
        case 'insertion':
            tableauInput.classList.remove('hidden');
            // Add position and value inputs
            if (!document.getElementById('position-input')) {
                const posValueDiv = document.createElement('div');
                posValueDiv.id = 'position-input';
                posValueDiv.className = 'hidden space-y-4';
                posValueDiv.innerHTML = `
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Position d'insertion:</label>
                        <input type="number" id="insert-position" min="0"
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-gray-700 mb-2">Valeur à insérer:</label>
                        <input type="number" id="insert-value"
                               class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                `;
                interactiveSection.insertBefore(posValueDiv, document.getElementById('execute-button'));
            }
            document.getElementById('position-input').classList.remove('hidden');
            break;
    }

    // Reset string input if we're not using it
    if (!['inverse', 'verif_lettres'].includes(algoType)) {
        document.querySelector('#number-input label').textContent = "Entrez un nombre:";
        document.getElementById('input-number').type = "number";
    }

    // Hide insertion inputs if not needed
    if (algoType !== 'insertion' && document.getElementById('position-input')) {
        document.getElementById('position-input').classList.add('hidden');
    }
}

function createArrayInputs() {
    const size = parseInt(arraySize.value);
    if (isNaN(size) || size < 1 || size > 20) {
        alert('Veuillez entrer une taille valide (entre 1 et 20)');
        return;
    }

    arrayElements.innerHTML = '';

    // Create a horizontal container for all elements
    const horizontalContainer = document.createElement('div');
    horizontalContainer.className = 'flex flex-wrap items-center gap-2';
    arrayElements.appendChild(horizontalContainer);

    for (let i = 0; i < size; i++) {
        const div = document.createElement('div');
        div.className = 'flex-shrink-0 flex items-center';
        div.innerHTML = `
            <label class="w-12 text-gray-700 text-sm">v[${i}]</label>
            <input type="number" id="array-element-${i}"
                   class="w-16 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
        `;
        horizontalContainer.appendChild(div);
    }

    // Add fade-in animation
    arrayElements.style.opacity = '0';
    arrayElements.classList.remove('hidden');
    setTimeout(() => {
        arrayElements.style.transition = 'opacity 0.3s ease-in-out';
        arrayElements.style.opacity = '1';
    }, 0);
}

function getArrayValues() {
    const size = parseInt(arraySize.value);
    const array = [];

    for (let i = 0; i < size; i++) {
        const element = document.getElementById(`array-element-${i}`);
        if (element) {
            const value = parseInt(element.value);
            array.push(isNaN(value) ? 0 : value);
        }
    }

    return array;
}

function executeAlgorithm() {
    // Find the selected algorithm
    const selectedCard = document.querySelector('#algorithm-cards .card.border-blue-500');
    if (!selectedCard) {
        alert('Veuillez sélectionner un algorithme');
        return;
    }

    const selectedAlgo = selectedCard.dataset.algo;
    let result = null;
    let steps = [];

    switch(selectedAlgo) {
        // Existing algorithm cases
        case 'remplir': {
            const array = getArrayValues();
            result = `Tableau rempli: [${array.join(', ')}]`;
            steps.push('Début de la procédure');
            for (let i = 0; i < array.length; i++) {
                steps.push(`v[${i}] = ${array[i]}`);
            }
            steps.push('Fin de la procédure');
            break;
        }

        case 'recherche': {
            const array = getArrayValues();
            const searchValue = parseInt(document.getElementById('search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche');
            steps.push(`i = 0, trouve = Faux`);

            let i = 0;
            let trouve = false;

            while (i < array.length && !trouve) {
                steps.push(`Vérification si v[${i}] = ${searchValue}`);
                if (array[i] === searchValue) {
                    trouve = true;
                    steps.push(`v[${i}] = ${searchValue}, donc trouve = Vrai`);
                } else {
                    steps.push(`v[${i}] ≠ ${searchValue}, donc i = i + 1 = ${i + 1}`);
                    i++;
                }
            }

            result = trouve ?
                `La valeur ${searchValue} a été trouvée à la position ${i}` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'recherche_sequentielle': {
            const array = getArrayValues();
            const searchValue = parseInt(document.getElementById('search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche séquentielle');
            let trouve = false;
            let i = 0;
            steps.push('trouve ← faux');
            steps.push('i ← 0');

            do {
                steps.push(`Vérification si t[${i}] = ${array[i]} == ${searchValue}`);
                if (array[i] === searchValue) {
                    trouve = true;
                    steps.push('trouve ← vrai');
                } else {
                    steps.push(`i ← i + 1 = ${i + 1}`);
                    i++;
                }
            } while (i <= array.length - 1 && !trouve);

            result = trouve ?
                `La valeur ${searchValue} a été trouvée à la position ${i}` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'recherche_dichotomique': {
            const array = getArrayValues();
            const searchValue = parseInt(document.getElementById('search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche dichotomique');
            let d = 0;
            let f = array.length - 1;
            let trouve = false;
            steps.push(`d ← 0, f ← ${array.length - 1}, trouve ← faux`);

            while (!trouve && d <= f) {
                let mil = Math.floor((d + f) / 2);
                steps.push(`Mil ← (d + f) div 2 = (${d} + ${f}) div 2 = ${mil}`);

                if (array[mil] === searchValue) {
                    trouve = true;
                    steps.push(`T[${mil}] = ${searchValue}, donc trouve ← vrai`);
                } else if (array[mil] < searchValue) {
                    steps.push(`T[${mil}] = ${array[mil]} < ${searchValue}, donc d ← Mil + 1 = ${mil + 1}`);
                    d = mil + 1;
                } else {
                    steps.push(`T[${mil}] = ${array[mil]} > ${searchValue}, donc f ← Mil - 1 = ${mil - 1}`);
                    f = mil - 1;
                }
            }

            result = trouve ?
                `La valeur ${searchValue} a été trouvée dans le tableau.` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau.`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'maximum': {
            const array = getArrayValues();
            if (array.length === 0) {
                alert('Le tableau doit contenir au moins un élément');
                return;
            }

            steps.push('Début de la fonction Maximum');
            steps.push(`Max = t[0] = ${array[0]}`);

            let max = array[0];

            for (let i = 1; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > Max = ${max}`);
                if (array[i] > max) {
                    max = array[i];
                    steps.push(`t[${i}] > Max, donc Max = ${max}`);
                } else {
                    steps.push(`t[${i}] ≤ Max, donc Max reste ${max}`);
                }
            }

            result = `Le maximum du tableau est: ${max}`;
            steps.push(`Retourne Max = ${max}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'somme': {
            const array = getArrayValues();

            steps.push('Début de la fonction somme');
            steps.push('S = 0');

            let sum = 0;

            for (let i = 0; i < array.length; i++) {
                sum += array[i];
                steps.push(`S = S + t[${i}] = ${sum - array[i]} + ${array[i]} = ${sum}`);
            }

            result = `La somme des éléments du tableau est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'sommediv': {
            const num = parseInt(document.getElementById('input-number').value);
            if (isNaN(num) || num <= 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction sommediv');
            steps.push('S = 0');

            let sum = 0;

            for (let i = 1; i <= num; i++) {
                steps.push(`Vérification si ${num} mod ${i} = ${num % i}`);
                if (num % i === 0) {
                    sum += i;
                    steps.push(`${i} est un diviseur de ${num}, donc S = S + ${i} = ${sum}`);
                } else {
                    steps.push(`${i} n'est pas un diviseur de ${num}`);
                }
            }

            result = `La somme des diviseurs de ${num} est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'pgcd': {
            let a = parseInt(document.getElementById('first-number').value);
            let b = parseInt(document.getElementById('second-number').value);
            if (isNaN(a) || isNaN(b) || a <= 0 || b <= 0) {
                alert('Veuillez entrer deux nombres entiers positifs');
                return;
            }

            steps.push('Début de la fonction pgcd');
            steps.push(`a = ${a}, b = ${b}`);

            let originalA = a;
            let originalB = b;

            while (a !== b) {
                steps.push(`a = ${a}, b = ${b}`);
                if (a > b) {
                    let oldA = a;
                    a = a - b;
                    steps.push(`a > b, donc a = ${oldA} - ${b} = ${a}`);
                } else {
                    let oldB = b;
                    b = b - a;
                    steps.push(`a ≤ b, donc b = ${oldB} - ${a} = ${b}`);
                }
            }

            result = `Le PGCD de ${originalA} et ${originalB} est: ${a}`;
            steps.push(`a = b = ${a}, donc PGCD = ${a}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'ppcm': {
            let a = parseInt(document.getElementById('first-number').value);
            let b = parseInt(document.getElementById('second-number').value);
            if (isNaN(a) || isNaN(b) || a <= 0 || b <= 0) {
                alert('Veuillez entrer deux nombres entiers positifs');
                return;
            }

            steps.push('Début de la fonction ppcm');
            steps.push(`a = ${a}, b = ${b}`);
            steps.push(`x = a = ${a}`);

            let x = a;
            let iterations = 0;
            const maxIterations = 1000; // Pour éviter les boucles infinies

            while (x % b !== 0 && iterations < maxIterations) {
                steps.push(`x mod b = ${x} mod ${b} = ${x % b} ≠ 0`);
                x = x + a;
                steps.push(`x = x + a = ${x - a} + ${a} = ${x}`);
                iterations++;
            }

            if (iterations >= maxIterations) {
                result = "Trop d'itérations, veuillez essayer des nombres plus petits";
            } else {
                result = `Le PPCM de ${a} et ${b} est: ${x}`;
                steps.push(`x mod b = ${x} mod ${b} = 0, donc PPCM = ${x}`);
                steps.push('Fin de la fonction');
            }
            break;
        }

        // Existing sorting algorithms
        case 'tri_selection':
        case 'tri_insertion':
        case 'tri_bulle':
            // Existing implementations
            break;

        // New algorithm implementations
        case 'saisir_controle': {
            const num = parseInt(document.getElementById('input-number').value);

            steps.push('Début de la procédure saisir');
            steps.push(`Saisie de m = ${num}`);

            if (num >= 5 && num <= 10) {
                result = `La valeur ${num} est valide car elle est comprise entre 5 et 10`;
                steps.push(`Vérification si ${num} dans [5..10] = Vrai`);
                steps.push('Fin de la procédure');
            } else {
                result = `La valeur ${num} est invalide, elle doit être comprise entre 5 et 10`;
                steps.push(`Vérification si ${num} dans [5..10] = Faux`);
                steps.push('Nécessite une nouvelle saisie');
            }
            break;
        }

        case 'remplir_simple': {
            const array = getArrayValues();
            result = `Tableau rempli: [${array.join(', ')}]`;
            steps.push('Début de la procédure remplir');
            for (let i = 0; i < array.length; i++) {
                steps.push(`v[${i}] = ${array[i]}`);
            }
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_positif': {
            const array = getArrayValues();
            steps.push('Début de la procédure remplir');

            let allPositive = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > 0`);
                if (array[i] <= 0) {
                    allPositive = false;
                    steps.push(`t[${i}] n'est pas positif, nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] = ${array[i]} est positif, accepté`);
                }
            }

            result = allPositive ?
                `Tableau rempli: [${array.join(', ')}]` :
                `Certaines valeurs ne sont pas positives, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_aleatoire': {
            const size = parseInt(arraySize.value);
            const randomArray = [];

            steps.push('Début de la procédure remplir');

            for (let i = 0; i < size; i++) {
                const randomValue = Math.floor(Math.random() * 81) + 10; // Between 10 and 90
                randomArray.push(randomValue);
                steps.push(`t[${i}] ← aléa(10, 90) = ${randomValue}`);
            }

            result = `Tableau rempli avec des valeurs aléatoires: [${randomArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_lettres': {
            const size = parseInt(arraySize.value);
            const randomArray = [];

            steps.push('Début de la procédure remplir');

            for (let i = 0; i < size; i++) {
                const randomChar = String.fromCharCode(Math.floor(Math.random() * 26) + 65); // A-Z
                randomArray.push(randomChar);
                steps.push(`t[${i}] ← chr(aléa(ord('A'), ord('Z'))) = ${randomChar}`);
            }

            result = `Tableau rempli avec des lettres aléatoires: [${randomArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_ordre': {
            const array = getArrayValues();
            steps.push('Début de la procédure remplir');

            let isOrdered = true;
            for (let i = 1; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > t[${i-1}] = ${array[i-1]}`);
                if (array[i] <= array[i-1]) {
                    isOrdered = false;
                    steps.push(`t[${i}] n'est pas supérieur à t[${i-1}], nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] est supérieur à t[${i-1}], accepté`);
                }
            }

            result = isOrdered ?
                `Tableau rempli en ordre: [${array.join(', ')}]` :
                `Certaines valeurs ne respectent pas l'ordre croissant, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_deuxchiffres': {
            const array = getArrayValues();
            steps.push('Début de la procédure remplir');

            let allTwoDigits = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si 10 <= t[${i}] = ${array[i]} <= 99`);
                if (array[i] < 10 || array[i] > 99) {
                    allTwoDigits = false;
                    steps.push(`t[${i}] n'est pas un entier à deux chiffres, nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] est un entier à deux chiffres, accepté`);
                }
            }

            result = allTwoDigits ?
                `Tableau rempli avec des entiers à deux chiffres: [${array.join(', ')}]` :
                `Certaines valeurs ne sont pas des entiers à deux chiffres, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_distinct': {
            const array = getArrayValues();
            steps.push('Début de la procédure remplir');

            // Check for duplicates
            const seen = new Set();
            let hasDuplicates = false;

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si la valeur ${array[i]} est déjà présente dans le tableau`);

                if (seen.has(array[i])) {
                    hasDuplicates = true;
                    steps.push(`La valeur ${array[i]} est déjà présente, nécessite une nouvelle saisie`);
                } else {
                    seen.add(array[i]);
                    steps.push(`La valeur ${array[i]} est unique, acceptée`);
                }
            }

            result = hasDuplicates ?
                `Des valeurs sont dupliquées, veuillez refaire la saisie` :
                `Tableau rempli avec des valeurs distinctes: [${array.join(', ')}]`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'nbocc': {
            const array = getArrayValues();
            const searchValue = parseInt(document.getElementById('search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction nbocc');
            steps.push(`nb = 0`);

            let count = 0;

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} = ${searchValue}`);
                if (array[i] === searchValue) {
                    count++;
                    steps.push(`t[${i}] = ${searchValue}, donc nb = nb + 1 = ${count}`);
                } else {
                    steps.push(`t[${i}] ≠ ${searchValue}, nb reste ${count}`);
                }
            }

            result = `Le nombre d'occurrences de ${searchValue} est: ${count}`;
            steps.push(`Retourne nb = ${count}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'verif_lettres': {
            const str = document.getElementById('input-number').value;

            steps.push('Début de la fonction verif');
            steps.push(`i = 0, test = Vrai`);

            let isValid = true;
            let i = 0;

            while (i < str.length && isValid) {
                const char = str[i].toUpperCase();
                steps.push(`Vérification si 'A' < majus(ch[${i}]) = '${char}' < 'Z'`);

                if (char >= 'A' && char <= 'Z') {
                    steps.push(`'${char}' est une lettre alphabétique, donc i = i + 1 = ${i + 1}`);
                    i++;
                } else {
                    isValid = false;
                    steps.push(`'${char}' n'est pas une lettre alphabétique, donc test = Faux`);
                }
            }

            result = isValid ?
                `La chaîne "${str}" ne contient que des lettres alphabétiques` :
                `La chaîne "${str}" contient des caractères non alphabétiques`;

            steps.push(`Retourne test = ${isValid ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'inverse': {
            const str = document.getElementById('input-number').value;

            steps.push('Début de la fonction inverse');
            steps.push(`ch1 = ''`);

            let reversed = '';

            for (let i = 0; i < str.length; i++) {
                reversed = str[i] + reversed;
                steps.push(`ch1 = ch[${i}] + ch1 = '${str[i]}' + '${reversed.substring(1)}' = '${reversed}'`);
            }

            result = `L'inverse de "${str}" est: "${reversed}"`;
            steps.push(`Retourne ch1 = '${reversed}'`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'nbdiv': {
            const num = parseInt(document.getElementById('input-number').value);
            if (isNaN(num) || num <= 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction nbdiv');
            steps.push('nb = 0');

            let count = 0;

            for (let i = 1; i <= num; i++) {
                steps.push(`Vérification si ${num} mod ${i} = ${num % i}`);
                if (num % i === 0) {
                    count++;
                    steps.push(`${i} est un diviseur de ${num}, donc nb = nb + 1 = ${count}`);
                } else {
                    steps.push(`${i} n'est pas un diviseur de ${num}`);
                }
            }

            result = `Le nombre de diviseurs de ${num} est: ${count}`;
            steps.push(`Retourne nb = ${count}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'sommechiffre': {
            let num = parseInt(document.getElementById('input-number').value);
            if (isNaN(num) || num < 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction sommechiffre');
            steps.push('S = 0');

            let sum = 0;
            let originalNum = num;

            do {
                const digit = num % 10;
                sum += digit;
                steps.push(`S = S + N MOD 10 = ${sum - digit} + ${digit} = ${sum}`);

                num = Math.floor(num / 10);
                steps.push(`N = N DIV 10 = ${num}`);
            } while (num > 0);

            result = `La somme des chiffres de ${originalNum} est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'affichage': {
            const array = getArrayValues();

            steps.push('Début de la procédure affichage');
            let output = '';

            for (let i = 0; i < array.length; i++) {
                steps.push(`Affichage: V[${i}] = ${array[i]}`);
                output += `V[${i}] = ${array[i]}<br>`;
            }

            result = output;
            steps.push('Fin de la procédure');
            break;
        }

        case 'affichage_pairs': {
            const array = getArrayValues();

            steps.push('Début de la procédure affiche');
            let output = '';

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} mod 2 = ${array[i] % 2}`);
                if (array[i] % 2 === 0) {
                    steps.push(`t[${i}] est pair, donc affichage: T[${i}] = ${array[i]}`);
                    output += `T[${i}] = ${array[i]}<br>`;
                } else {
                    steps.push(`t[${i}] est impair, pas d'affichage`);
                }
            }

            result = output || 'Aucun élément pair dans le tableau';
            steps.push('Fin de la procédure');
            break;
        }

        case 'extraire': {
            const array = getArrayValues();

            steps.push('Début de la procédure extraire');
            steps.push('j = 0, k = 0');

            const evens = [];
            const odds = [];

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} mod 2 = ${array[i] % 2}`);
                if (array[i] % 2 === 0) {
                    evens.push(array[i]);
                    steps.push(`t[${i}] est pair, donc Tp[${evens.length - 1}] = ${array[i]}, j = j + 1 = ${evens.length}`);
                } else {
                    odds.push(array[i]);
                    steps.push(`t[${i}] est impair, donc Timp[${odds.length - 1}] = ${array[i]}, k = k + 1 = ${odds.length}`);
                }
            }

            result = `Tableau des éléments pairs (TP): [${evens.join(', ')}]<br>Tableau des éléments impairs (Timp): [${odds.join(', ')}]`;
            steps.push(`Tableau TP de taille ${evens.length}: [${evens.join(', ')}]`);
            steps.push(`Tableau Timp de taille ${odds.length}: [${odds.join(', ')}]`);
            steps.push('Fin de la procédure');
            break;
        }

        case 'insertion': {
            const array = getArrayValues();
            const position = parseInt(document.getElementById('insert-position').value);
            const value = parseInt(document.getElementById('insert-value').value);

            if (isNaN(position) || position < 0 || position > array.length) {
                alert(`La position doit être entre 0 et ${array.length}`);
                return;
            }

            if (isNaN(value)) {
                alert('Veuillez entrer une valeur à insérer valide');
                return;
            }

            steps.push('Début de la procédure insertion');

            const result_array = [...array];
            // Push a placeholder to increase array size
            result_array.push(null);

            for (let i = result_array.length - 1; i > position; i--) {
                result_array[i] = result_array[i - 1];
                steps.push(`t[${i}] = t[${i-1}] = ${result_array[i]}`);
            }

            result_array[position] = value;
            steps.push(`t[${position}] = ${value}`);

            result = `Tableau après insertion: [${result_array.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_lettresonly': {
            // Get values from the modal array inputs as strings
            const size = parseInt(document.getElementById('modal-array-size').value);
            const array = [];

            for (let i = 0; i < size; i++) {
                const element = document.getElementById(`modal-array-element-${i}`);
                if (element) {
                    array.push(element.value.toString());
                }
            }

            steps.push('Début de la procédure remplir');

            // Helper function to check if a string contains only letters
            const containsOnlyLetters = str => /^[A-Za-z]+$/.test(str);

            let allLetters = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si verif(t[${i}]) = verif("${array[i]}")`);

                if (containsOnlyLetters(array[i])) {
                    steps.push(`"${array[i]}" ne contient que des lettres, accepté`);
                } else {
                    allLetters = false;
                    steps.push(`"${array[i]}" contient des caractères non alphabétiques, nécessite une nouvelle saisie`);
                }
            }

            result = allLetters ?
                `Tableau rempli avec des chaînes alphabétiques: [${array.join(', ')}]` :
                `Certaines valeurs contiennent des caractères non alphabétiques, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        default:
            result = "Algorithme non implémenté";
    }

    // Display results with animation
    if (result) {
        // Handle HTML content in result
        if (result.includes('<br>')) {
            resultContent.innerHTML = result;
        } else {
            resultContent.textContent = result;
        }

        executionSteps.innerHTML = steps.map(step =>
            `<div class="execution-step">${step}</div>`
        ).join('');

        // Fade in results
        resultsSection.style.opacity = '0';
        resultsSection.classList.remove('hidden');
        setTimeout(() => {
            resultsSection.style.transition = 'opacity 0.3s ease-in-out';
            resultsSection.style.opacity = '1';

            // Ensure scrolling works by setting explicit styles
            executionSteps.style.overflowY = 'auto';
            executionSteps.style.maxHeight = '400px';
            executionSteps.style.display = 'block';

            // Scroll to the top of the execution steps
            executionSteps.scrollTop = 0;

            // Ensure modal execution steps also have proper scrolling
            const modalExecutionSteps = document.getElementById('modal-execution-steps');
            if (modalExecutionSteps) {
                modalExecutionSteps.style.overflowY = 'auto';
                modalExecutionSteps.style.maxHeight = '400px';
                modalExecutionSteps.style.display = 'block';
                modalExecutionSteps.scrollTop = 0;
            }
        }, 0);
    }
}

// Populate array with random numbers
function fillRandomArray() {
    const size = parseInt(arraySize.value);
    if (isNaN(size) || size < 1 || size > 20) return;

    for (let i = 0; i < size; i++) {
        const element = document.getElementById(`array-element-${i}`);
        if (element) {
            element.value = Math.floor(Math.random() * 100);
        }
    }
}

// Add input validation and formatting
document.querySelectorAll('input[type="number"]').forEach(input => {
    input.addEventListener('input', function() {
        if (this.value === '') return;
        const num = parseInt(this.value);
        if (isNaN(num)) {
            this.classList.add('border-red-500');
        } else {
            this.classList.remove('border-red-500');
        }
    });
});

// Add loading state to buttons
document.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', function() {
        if (this.dataset.loading) return;

        const originalText = this.textContent;
        this.dataset.loading = 'true';
        this.innerHTML = `
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            ${originalText}
        `;

        setTimeout(() => {
            this.innerHTML = originalText;
            delete this.dataset.loading;
        }, 500);
    });
});

// Function to open the algorithm modal
function openAlgorithmModal(algoKey) {
    const algo = algorithms[algoKey];
    const modal = document.getElementById('algorithm-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalAlgorithmInfo = document.getElementById('modal-algorithm-info');
    const modalInteractiveSection = document.getElementById('modal-interactive-section');
    const modalResultsSection = document.getElementById('modal-results-section');

    // Set modal title
    modalTitle.textContent = algo.title;

    // Prepare algorithm info
    modalAlgorithmInfo.innerHTML = `
        <h2 class="text-2xl font-bold mb-4 text-gray-800">Description de l'algorithme</h2>
        <div class="pseudo-code p-4 rounded-lg mb-4">
            <pre class="whitespace-pre-wrap text-sm">${algo.pseudocode}</pre>
        </div>
        <p class="text-gray-600 mb-4">${algo.description}</p>
    `;

    // Prepare interactive section
    modalInteractiveSection.innerHTML = `
        <h2 class="text-2xl font-bold mb-4 text-gray-800">Section Interactive</h2>
        <div id="modal-tableau-input" class="hidden space-y-4">
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">Taille du tableau:</label>
                <input type="number" id="modal-array-size" min="1" max="20" value="5"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <div class="flex space-x-2 mt-2">
                    <button id="modal-generate-array"
                            class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                        Générer un tableau
                    </button>
                    <button id="modal-random-fill"
                            class="flex-1 bg-yellow-500 text-white py-2 px-4 rounded-lg hover:bg-yellow-600 focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2">
                        Valeurs aléatoires
                    </button>
                </div>
            </div>
            <div id="modal-array-elements" class="hidden space-y-2">
                <!-- Array elements will be added here dynamically -->
            </div>
        </div>

        <div id="modal-number-input" class="hidden space-y-4">
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">Entrez un nombre:</label>
                <input type="number" id="modal-input-number"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <div id="modal-two-numbers-input" class="hidden space-y-4">
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">a:</label>
                <input type="number" id="modal-first-number"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">b:</label>
                <input type="number" id="modal-second-number"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <div id="modal-search-input" class="hidden space-y-4">
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">Valeur à rechercher:</label>
                <input type="number" id="modal-search-value"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <div id="modal-position-input" class="hidden space-y-4">
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">Position d'insertion:</label>
                <input type="number" id="modal-insert-position" min="0"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="flex flex-col">
                <label class="text-gray-700 mb-2">Valeur à insérer:</label>
                <input type="number" id="modal-insert-value"
                       class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <button id="modal-execute-button"
                class="mt-6 w-full bg-green-500 text-white py-3 px-6 rounded-lg hover:bg-green-600 focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
            Exécuter
        </button>
    `;

    // Prepare results section
    modalResultsSection.innerHTML = `
        <h2 class="text-2xl font-bold mb-4 text-gray-800">Résultats</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
                <div id="modal-result-content" class="bg-blue-50 p-4 rounded-lg text-blue-800 max-h-[400px] overflow-y-auto"></div>
            </div>
            <div id="modal-step-by-step">
                <h3 class="font-bold mb-3 text-gray-800">Étapes d'exécution:</h3>
                <div id="modal-execution-steps" class="space-y-2 max-h-[400px] overflow-y-auto pr-2">
                    <!-- Steps will be added here dynamically -->
                </div>
            </div>
        </div>
    `;

    // Set up interactive section based on algorithm type
    setupModalInteractiveSection(algoKey);

    // Show the modal with animation
    document.body.classList.add('modal-open');
    modal.classList.remove('hidden');
    setTimeout(() => {
        modal.classList.remove('opacity-0');
    }, 10);

    // Add event listeners for modal functionality
    setupModalEventListeners(algoKey);
}

// Function to close the algorithm modal
function closeAlgorithmModal() {
    const modal = document.getElementById('algorithm-modal');

    // Hide with animation
    modal.classList.add('opacity-0');
    setTimeout(() => {
        modal.classList.add('hidden');
        document.body.classList.remove('modal-open');

        // Reset modal state
        document.getElementById('modal-results-section').classList.add('hidden');

        // Ensure body scrolling is restored
        document.body.style.overflow = 'auto';
        document.documentElement.style.overflow = 'auto';
    }, 300);
}

// Setup modal event listeners
function setupModalEventListeners(algoKey) {
    // Close button
    document.getElementById('close-modal').addEventListener('click', closeAlgorithmModal);

    // Close on ESC key
    const closeOnEsc = function(e) {
        if (e.key === 'Escape') {
            closeAlgorithmModal();
            document.removeEventListener('keydown', closeOnEsc);
        }
    };
    document.addEventListener('keydown', closeOnEsc);

    // Close on outside click
    const modalElement = document.getElementById('algorithm-modal');
    const closeOnOutsideClick = function(e) {
        if (e.target === modalElement) {
            closeAlgorithmModal();
            modalElement.removeEventListener('click', closeOnOutsideClick);
        }
    };
    modalElement.addEventListener('click', closeOnOutsideClick);

    // Generate array button
    const generateArrayBtn = document.getElementById('modal-generate-array');
    if (generateArrayBtn) {
        // Remove any existing event listeners
        const newGenerateBtn = generateArrayBtn.cloneNode(true);
        generateArrayBtn.parentNode.replaceChild(newGenerateBtn, generateArrayBtn);
        newGenerateBtn.addEventListener('click', createModalArrayInputs);
    }

    // Random fill button
    const randomFillBtn = document.getElementById('modal-random-fill');
    if (randomFillBtn) {
        // Remove any existing event listeners
        const newRandomFillBtn = randomFillBtn.cloneNode(true);
        randomFillBtn.parentNode.replaceChild(newRandomFillBtn, randomFillBtn);
        newRandomFillBtn.addEventListener('click', function() {
            createModalArrayInputs();
            fillModalRandomArray();
        });
    }

    // Execute button
    const executeBtn = document.getElementById('modal-execute-button');
    if (executeBtn) {
        // Remove any existing event listeners
        const newExecuteBtn = executeBtn.cloneNode(true);
        executeBtn.parentNode.replaceChild(newExecuteBtn, executeBtn);
        newExecuteBtn.addEventListener('click', function() {
            executeModalAlgorithm(algoKey);
        });
    }
}

// Setup modal interactive section
function setupModalInteractiveSection(algoType) {
    // References to modal elements
    const tableauInput = document.getElementById('modal-tableau-input');
    const numberInput = document.getElementById('modal-number-input');
    const twoNumbersInput = document.getElementById('modal-two-numbers-input');
    const searchInput = document.getElementById('modal-search-input');
    const positionInput = document.getElementById('modal-position-input');

    // Hide all input sections first
    tableauInput.classList.add('hidden');
    numberInput.classList.add('hidden');
    twoNumbersInput.classList.add('hidden');
    searchInput.classList.add('hidden');
    positionInput.classList.add('hidden');

    // Show appropriate inputs based on algorithm type
    switch(algoType) {
        // Array inputs
        case 'remplir':
        case 'maximum':
        case 'somme':
        case 'tri_selection':
        case 'tri_insertion':
        case 'tri_bulle':
        case 'remplir_simple':
        case 'remplir_positif':
        case 'remplir_aleatoire':
        case 'remplir_lettres':
        case 'remplir_ordre':
        case 'remplir_deuxchiffres':
        case 'remplir_distinct':
        case 'remplir_lettresonly':
        case 'affichage':
        case 'affichage_pairs':
        case 'extraire':
            tableauInput.classList.remove('hidden');
            break;

        // Array with search
        case 'recherche':
        case 'nbocc':
        case 'recherche_sequentielle':
        case 'recherche_dichotomique':
            tableauInput.classList.remove('hidden');
            searchInput.classList.remove('hidden');
            break;

        // Single number input
        case 'sommediv':
        case 'nbdiv':
        case 'sommechiffre':
        case 'saisir_controle':
            numberInput.classList.remove('hidden');
            break;

        // String input for string operations
        case 'inverse':
        case 'verif_lettres':
            // Reuse the number input field but change the label
            document.querySelector('#modal-number-input label').textContent = "Entrez une chaîne:";
            document.getElementById('modal-input-number').type = "text";
            numberInput.classList.remove('hidden');
            break;

        // Two numbers input
        case 'pgcd':
        case 'ppcm':
            twoNumbersInput.classList.remove('hidden');
            break;

        // Insertion needs array + position + value
        case 'insertion':
            tableauInput.classList.remove('hidden');
            positionInput.classList.remove('hidden');
            break;
    }

    // Reset string input if we're not using it
    if (!['inverse', 'verif_lettres'].includes(algoType)) {
        const label = document.querySelector('#modal-number-input label');
        if (label) {
            label.textContent = "Entrez un nombre:";
        }
        const input = document.getElementById('modal-input-number');
        if (input) {
            input.type = "number";
        }
    }
}

// Create array inputs in modal
function createModalArrayInputs() {
    const arraySize = document.getElementById('modal-array-size');
    const arrayElements = document.getElementById('modal-array-elements');

    const size = parseInt(arraySize.value);
    if (isNaN(size) || size < 1 || size > 20) {
        alert('Veuillez entrer une taille valide (entre 1 et 20)');
        return;
    }

    arrayElements.innerHTML = '';

    // Create a horizontal container for all elements
    const horizontalContainer = document.createElement('div');
    horizontalContainer.className = 'flex flex-wrap items-center gap-2';
    arrayElements.appendChild(horizontalContainer);

    for (let i = 0; i < size; i++) {
        const div = document.createElement('div');
        div.className = 'flex-shrink-0 flex items-center';
        div.innerHTML = `
            <label class="w-12 text-gray-700 text-sm">v[${i}]</label>
            <input type="number" id="modal-array-element-${i}"
                   class="w-16 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
        `;
        horizontalContainer.appendChild(div);
    }

    // Add fade-in animation
    arrayElements.style.opacity = '0';
    arrayElements.classList.remove('hidden');
    setTimeout(() => {
        arrayElements.style.transition = 'opacity 0.3s ease-in-out';
        arrayElements.style.opacity = '1';
    }, 0);
}

// Fill array with random values in modal
function fillModalRandomArray() {
    const arraySize = document.getElementById('modal-array-size');
    const size = parseInt(arraySize.value);
    if (isNaN(size) || size < 1 || size > 20) return;

    for (let i = 0; i < size; i++) {
        const element = document.getElementById(`modal-array-element-${i}`);
        if (element) {
            element.value = Math.floor(Math.random() * 100);
        }
    }
}

// Get array values from modal
function getModalArrayValues() {
    const arraySize = document.getElementById('modal-array-size');
    const size = parseInt(arraySize.value);
    const array = [];

    for (let i = 0; i < size; i++) {
        const element = document.getElementById(`modal-array-element-${i}`);
        if (element) {
            const value = parseInt(element.value);
            array.push(isNaN(value) ? 0 : value);
        }
    }

    return array;
}

// Execute algorithm in modal
function executeModalAlgorithm(algoKey) {
    const resultsSection = document.getElementById('modal-results-section');
    const resultContent = document.getElementById('modal-result-content');
    const executionSteps = document.getElementById('modal-execution-steps');

    let result = null;
    let steps = [];

    // Reuse existing algorithm logic with modal inputs
    switch(algoKey) {
        case 'maximum': {
            const array = getModalArrayValues();
            if (array.length === 0) {
                alert('Le tableau doit contenir au moins un élément');
                return;
            }

            steps.push('Début de la fonction Maximum');
            steps.push(`Max = t[0] = ${array[0]}`);

            let max = array[0];

            for (let i = 1; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > Max = ${max}`);
                if (array[i] > max) {
                    max = array[i];
                    steps.push(`t[${i}] > Max, donc Max = ${max}`);
                } else {
                    steps.push(`t[${i}] ≤ Max, donc Max reste ${max}`);
                }
            }

            result = `Le maximum du tableau est: ${max}`;
            steps.push(`Retourne Max = ${max}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'remplir':
        case 'remplir_simple': {
            const array = getModalArrayValues();
            result = `Tableau rempli: [${array.join(', ')}]`;
            steps.push('Début de la procédure');
            for (let i = 0; i < array.length; i++) {
                steps.push(`v[${i}] = ${array[i]}`);
            }
            steps.push('Fin de la procédure');
            break;
        }

        case 'recherche': {
            const array = getModalArrayValues();
            const searchValue = parseInt(document.getElementById('modal-search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche');
            steps.push(`i = 0, trouve = Faux`);

            let i = 0;
            let trouve = false;

            while (i < array.length && !trouve) {
                steps.push(`Vérification si v[${i}] = ${searchValue}`);
                if (array[i] === searchValue) {
                    trouve = true;
                    steps.push(`v[${i}] = ${searchValue}, donc trouve = Vrai`);
                } else {
                    steps.push(`v[${i}] ≠ ${searchValue}, donc i = i + 1 = ${i + 1}`);
                    i++;
                }
            }

            result = trouve ?
                `La valeur ${searchValue} a été trouvée à la position ${i}` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'recherche_sequentielle': {
            const array = getModalArrayValues();
            const searchValue = parseInt(document.getElementById('modal-search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche séquentielle');
            let trouve = false;
            let i = 0;
            steps.push('trouve ← faux');
            steps.push('i ← 0');

            do {
                steps.push(`Vérification si t[${i}] = ${array[i]} == ${searchValue}`);
                if (array[i] === searchValue) {
                    trouve = true;
                    steps.push('trouve ← vrai');
                } else {
                    steps.push(`i ← i + 1 = ${i + 1}`);
                    i++;
                }
            } while (i <= array.length - 1 && !trouve);

            result = trouve ?
                `La valeur ${searchValue} a été trouvée à la position ${i}` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'recherche_dichotomique': {
            const array = getModalArrayValues();
            const searchValue = parseInt(document.getElementById('modal-search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction recherche dichotomique');
            let d = 0;
            let f = array.length - 1;
            let trouve = false;
            steps.push(`d ← 0, f ← ${array.length - 1}, trouve ← faux`);

            while (!trouve && d <= f) {
                let mil = Math.floor((d + f) / 2);
                steps.push(`Mil ← (d + f) div 2 = (${d} + ${f}) div 2 = ${mil}`);

                if (array[mil] === searchValue) {
                    trouve = true;
                    steps.push(`T[${mil}] = ${searchValue}, donc trouve ← vrai`);
                } else if (array[mil] < searchValue) {
                    steps.push(`T[${mil}] = ${array[mil]} < ${searchValue}, donc d ← Mil + 1 = ${mil + 1}`);
                    d = mil + 1;
                } else {
                    steps.push(`T[${mil}] = ${array[mil]} > ${searchValue}, donc f ← Mil - 1 = ${mil - 1}`);
                    f = mil - 1;
                }
            }

            result = trouve ?
                `La valeur ${searchValue} a été trouvée dans le tableau.` :
                `La valeur ${searchValue} n'a pas été trouvée dans le tableau.`;

            steps.push(`Résultat: ${trouve ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'somme': {
            const array = getModalArrayValues();

            steps.push('Début de la fonction somme');
            steps.push('S = 0');

            let sum = 0;

            for (let i = 0; i < array.length; i++) {
                sum += array[i];
                steps.push(`S = S + t[${i}] = ${sum - array[i]} + ${array[i]} = ${sum}`);
            }

            result = `La somme des éléments du tableau est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'sommediv': {
            const num = parseInt(document.getElementById('modal-input-number').value);
            if (isNaN(num) || num <= 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction sommediv');
            steps.push('S = 0');

            let sum = 0;

            for (let i = 1; i <= num; i++) {
                steps.push(`Vérification si ${num} mod ${i} = ${num % i}`);
                if (num % i === 0) {
                    sum += i;
                    steps.push(`${i} est un diviseur de ${num}, donc S = S + ${i} = ${sum}`);
                } else {
                    steps.push(`${i} n'est pas un diviseur de ${num}`);
                }
            }

            result = `La somme des diviseurs de ${num} est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'pgcd': {
            let a = parseInt(document.getElementById('modal-first-number').value);
            let b = parseInt(document.getElementById('modal-second-number').value);
            if (isNaN(a) || isNaN(b) || a <= 0 || b <= 0) {
                alert('Veuillez entrer deux nombres entiers positifs');
                return;
            }

            steps.push('Début de la fonction pgcd');
            steps.push(`a = ${a}, b = ${b}`);

            let originalA = a;
            let originalB = b;

            while (a !== b) {
                steps.push(`a = ${a}, b = ${b}`);
                if (a > b) {
                    let oldA = a;
                    a = a - b;
                    steps.push(`a > b, donc a = ${oldA} - ${b} = ${a}`);
                } else {
                    let oldB = b;
                    b = b - a;
                    steps.push(`a ≤ b, donc b = ${oldB} - ${a} = ${b}`);
                }
            }

            result = `Le PGCD de ${originalA} et ${originalB} est: ${a}`;
            steps.push(`a = b = ${a}, donc PGCD = ${a}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'ppcm': {
            let a = parseInt(document.getElementById('modal-first-number').value);
            let b = parseInt(document.getElementById('modal-second-number').value);
            if (isNaN(a) || isNaN(b) || a <= 0 || b <= 0) {
                alert('Veuillez entrer deux nombres entiers positifs');
                return;
            }

            steps.push('Début de la fonction ppcm');
            steps.push(`a = ${a}, b = ${b}`);
            steps.push(`x = a = ${a}`);

            let x = a;
            let iterations = 0;
            const maxIterations = 1000; // Pour éviter les boucles infinies

            while (x % b !== 0 && iterations < maxIterations) {
                steps.push(`x mod b = ${x} mod ${b} = ${x % b} ≠ 0`);
                x = x + a;
                steps.push(`x = x + a = ${x - a} + ${a} = ${x}`);
                iterations++;
            }

            if (iterations >= maxIterations) {
                result = "Trop d'itérations, veuillez essayer des nombres plus petits";
            } else {
                result = `Le PPCM de ${a} et ${b} est: ${x}`;
                steps.push(`x mod b = ${x} mod ${b} = 0, donc PPCM = ${x}`);
                steps.push('Fin de la fonction');
            }
            break;
        }

        case 'tri_selection': {
            const array = getModalArrayValues();
            if (array.length === 0) {
                alert('Le tableau doit contenir au moins un élément');
                return;
            }

            steps.push('Début de la procédure TriParSélection');

            const sortedArray = [...array];

            for (let i = 0; i < sortedArray.length - 1; i++) {
                steps.push(`Itération i=${i}: Recherche du minimum à partir de la position ${i}`);
                let minIndex = i;
                steps.push(`Initialisation: pmin = ${i}`);

                for (let j = i + 1; j < sortedArray.length; j++) {
                    steps.push(`Comparaison: T[${j}]=${sortedArray[j]} < T[${minIndex}]=${sortedArray[minIndex]} ?`);

                    if (sortedArray[j] < sortedArray[minIndex]) {
                        minIndex = j;
                        steps.push(`Nouveau minimum trouvé: pmin = ${j}`);
                    } else {
                        steps.push(`Pas de nouveau minimum, pmin reste ${minIndex}`);
                    }
                }

                if (i !== minIndex) {
                    steps.push(`Échange des éléments: T[${i}]=${sortedArray[i]} et T[${minIndex}]=${sortedArray[minIndex]}`);
                    const temp = sortedArray[i];
                    sortedArray[i] = sortedArray[minIndex];
                    sortedArray[minIndex] = temp;
                    steps.push(`Tableau après échange: [${sortedArray.join(', ')}]`);
                } else {
                    steps.push(`Pas d'échange nécessaire car i = pmin = ${i}`);
                }
            }

            result = `Tableau trié: [${sortedArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'tri_insertion': {
            const array = getModalArrayValues();
            if (array.length === 0) {
                alert('Le tableau doit contenir au moins un élément');
                return;
            }

            steps.push('Début de la procédure TriParInsertion');

            const sortedArray = [...array];

            for (let i = 1; i < sortedArray.length; i++) {
                const tmp = sortedArray[i];
                steps.push(`Itération i=${i}: Insertion de l'élément ${tmp}`);
                steps.push(`Tmp = T[${i}] = ${tmp}`);

                let j = i - 1;
                steps.push(`j = i - 1 = ${j}`);

                steps.push(`Comparaison: T[${j}]=${sortedArray[j]} > Tmp=${tmp} et j >= 0 ?`);

                while (j >= 0 && sortedArray[j] > tmp) {
                    sortedArray[j + 1] = sortedArray[j];
                    steps.push(`Décalage: T[${j+1}] = T[${j}] = ${sortedArray[j]}`);

                    j--;
                    steps.push(`j = j - 1 = ${j}`);

                    if (j >= 0) {
                        steps.push(`Comparaison: T[${j}]=${sortedArray[j]} > Tmp=${tmp} et j >= 0 ?`);
                    }
                }

                sortedArray[j + 1] = tmp;
                steps.push(`Insertion: T[${j+1}] = Tmp = ${tmp}`);
                steps.push(`Tableau après insertion: [${sortedArray.join(', ')}]`);
            }

            result = `Tableau trié: [${sortedArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'tri_bulle': {
            const array = getModalArrayValues();
            if (array.length === 0) {
                alert('Le tableau doit contenir au moins un élément');
                return;
            }

            steps.push('Début de la procédure Tri_A_Bulle');

            const sortedArray = [...array];
            let iteration = 0;
            let permut;

            do {
                iteration++;
                steps.push(`Itération ${iteration}`);
                steps.push(`Permut = Faux`);
                permut = false;

                for (let i = 0; i < sortedArray.length - 1; i++) {
                    steps.push(`Comparaison: T[${i}]=${sortedArray[i]} > T[${i+1}]=${sortedArray[i+1]} ?`);

                    if (sortedArray[i] > sortedArray[i + 1]) {
                        steps.push(`Échange des éléments: T[${i}]=${sortedArray[i]} et T[${i+1}]=${sortedArray[i+1]}`);

                        const aux = sortedArray[i];
                        sortedArray[i] = sortedArray[i + 1];
                        sortedArray[i + 1] = aux;

                        permut = true;
                        steps.push(`Permut = Vrai`);
                        steps.push(`Tableau après échange: [${sortedArray.join(', ')}]`);
                    } else {
                        steps.push(`Pas d'échange nécessaire`);
                    }
                }

                steps.push(`Fin de l'itération ${iteration}, Permut = ${permut ? 'Vrai' : 'Faux'}`);
            } while (permut);

            result = `Tableau trié: [${sortedArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'saisir_controle': {
            const num = parseInt(document.getElementById('modal-input-number').value);

            steps.push('Début de la procédure saisir');
            steps.push(`Saisie de m = ${num}`);

            if (num >= 5 && num <= 10) {
                result = `La valeur ${num} est valide car elle est comprise entre 5 et 10`;
                steps.push(`Vérification si ${num} dans [5..10] = Vrai`);
                steps.push('Fin de la procédure');
            } else {
                result = `La valeur ${num} est invalide, elle doit être comprise entre 5 et 10`;
                steps.push(`Vérification si ${num} dans [5..10] = Faux`);
                steps.push('Nécessite une nouvelle saisie');
            }
            break;
        }

        case 'remplir_positif': {
            const array = getModalArrayValues();
            steps.push('Début de la procédure remplir');

            let allPositive = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > 0`);
                if (array[i] <= 0) {
                    allPositive = false;
                    steps.push(`t[${i}] n'est pas positif, nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] = ${array[i]} est positif, accepté`);
                }
            }

            result = allPositive ?
                `Tableau rempli: [${array.join(', ')}]` :
                `Certaines valeurs ne sont pas positives, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_aleatoire': {
            const size = parseInt(document.getElementById('modal-array-size').value);
            const randomArray = [];

            steps.push('Début de la procédure remplir');

            for (let i = 0; i < size; i++) {
                const randomValue = Math.floor(Math.random() * 81) + 10; // Between 10 and 90
                randomArray.push(randomValue);
                steps.push(`t[${i}] ← aléa(10, 90) = ${randomValue}`);
            }

            result = `Tableau rempli avec des valeurs aléatoires: [${randomArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_lettres': {
            const size = parseInt(document.getElementById('modal-array-size').value);
            const randomArray = [];

            steps.push('Début de la procédure remplir');

            for (let i = 0; i < size; i++) {
                const randomChar = String.fromCharCode(Math.floor(Math.random() * 26) + 65); // A-Z
                randomArray.push(randomChar);
                steps.push(`t[${i}] ← chr(aléa(ord('A'), ord('Z'))) = ${randomChar}`);
            }

            result = `Tableau rempli avec des lettres aléatoires: [${randomArray.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_ordre': {
            const array = getModalArrayValues();
            steps.push('Début de la procédure remplir');

            let isOrdered = true;
            for (let i = 1; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} > t[${i-1}] = ${array[i-1]}`);
                if (array[i] <= array[i-1]) {
                    isOrdered = false;
                    steps.push(`t[${i}] n'est pas supérieur à t[${i-1}], nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] est supérieur à t[${i-1}], accepté`);
                }
            }

            result = isOrdered ?
                `Tableau rempli en ordre: [${array.join(', ')}]` :
                `Certaines valeurs ne respectent pas l'ordre croissant, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_deuxchiffres': {
            const array = getModalArrayValues();
            steps.push('Début de la procédure remplir');

            let allTwoDigits = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si 10 <= t[${i}] = ${array[i]} <= 99`);
                if (array[i] < 10 || array[i] > 99) {
                    allTwoDigits = false;
                    steps.push(`t[${i}] n'est pas un entier à deux chiffres, nécessite une nouvelle saisie`);
                } else {
                    steps.push(`t[${i}] est un entier à deux chiffres, accepté`);
                }
            }

            result = allTwoDigits ?
                `Tableau rempli avec des entiers à deux chiffres: [${array.join(', ')}]` :
                `Certaines valeurs ne sont pas des entiers à deux chiffres, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_distinct': {
            const array = getModalArrayValues();
            steps.push('Début de la procédure remplir');

            // Check for duplicates
            const seen = new Set();
            let hasDuplicates = false;

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si la valeur ${array[i]} est déjà présente dans le tableau`);

                if (seen.has(array[i])) {
                    hasDuplicates = true;
                    steps.push(`La valeur ${array[i]} est déjà présente, nécessite une nouvelle saisie`);
                } else {
                    seen.add(array[i]);
                    steps.push(`La valeur ${array[i]} est unique, acceptée`);
                }
            }

            result = hasDuplicates ?
                `Des valeurs sont dupliquées, veuillez refaire la saisie` :
                `Tableau rempli avec des valeurs distinctes: [${array.join(', ')}]`;

            steps.push('Fin de la procédure');
            break;
        }

        case 'nbocc': {
            const array = getModalArrayValues();
            const searchValue = parseInt(document.getElementById('modal-search-value').value);
            if (isNaN(searchValue)) {
                alert('Veuillez entrer une valeur de recherche valide');
                return;
            }

            steps.push('Début de la fonction nbocc');
            steps.push(`nb = 0`);

            let count = 0;

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} = ${searchValue}`);
                if (array[i] === searchValue) {
                    count++;
                    steps.push(`t[${i}] = ${searchValue}, donc nb = nb + 1 = ${count}`);
                } else {
                    steps.push(`t[${i}] ≠ ${searchValue}, nb reste ${count}`);
                }
            }

            result = `Le nombre d'occurrences de ${searchValue} est: ${count}`;
            steps.push(`Retourne nb = ${count}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'verif_lettres': {
            const str = document.getElementById('modal-input-number').value;

            steps.push('Début de la fonction verif');
            steps.push(`i = 0, test = Vrai`);

            let isValid = true;
            let i = 0;

            while (i < str.length && isValid) {
                const char = str[i].toUpperCase();
                steps.push(`Vérification si 'A' < majus(ch[${i}]) = '${char}' < 'Z'`);

                if (char >= 'A' && char <= 'Z') {
                    steps.push(`'${char}' est une lettre alphabétique, donc i = i + 1 = ${i + 1}`);
                    i++;
                } else {
                    isValid = false;
                    steps.push(`'${char}' n'est pas une lettre alphabétique, donc test = Faux`);
                }
            }

            result = isValid ?
                `La chaîne "${str}" ne contient que des lettres alphabétiques` :
                `La chaîne "${str}" contient des caractères non alphabétiques`;

            steps.push(`Retourne test = ${isValid ? 'Vrai' : 'Faux'}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'inverse': {
            const str = document.getElementById('modal-input-number').value;

            steps.push('Début de la fonction inverse');
            steps.push(`ch1 = ''`);

            let reversed = '';

            for (let i = 0; i < str.length; i++) {
                reversed = str[i] + reversed;
                steps.push(`ch1 = ch[${i}] + ch1 = '${str[i]}' + '${reversed.substring(1)}' = '${reversed}'`);
            }

            result = `L'inverse de "${str}" est: "${reversed}"`;
            steps.push(`Retourne ch1 = '${reversed}'`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'nbdiv': {
            const num = parseInt(document.getElementById('modal-input-number').value);
            if (isNaN(num) || num <= 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction nbdiv');
            steps.push('nb = 0');

            let count = 0;

            for (let i = 1; i <= num; i++) {
                steps.push(`Vérification si ${num} mod ${i} = ${num % i}`);
                if (num % i === 0) {
                    count++;
                    steps.push(`${i} est un diviseur de ${num}, donc nb = nb + 1 = ${count}`);
                } else {
                    steps.push(`${i} n'est pas un diviseur de ${num}`);
                }
            }

            result = `Le nombre de diviseurs de ${num} est: ${count}`;
            steps.push(`Retourne nb = ${count}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'sommechiffre': {
            let num = parseInt(document.getElementById('modal-input-number').value);
            if (isNaN(num) || num < 0) {
                alert('Veuillez entrer un nombre entier positif');
                return;
            }

            steps.push('Début de la fonction sommechiffre');
            steps.push('S = 0');

            let sum = 0;
            let originalNum = num;

            do {
                const digit = num % 10;
                sum += digit;
                steps.push(`S = S + N MOD 10 = ${sum - digit} + ${digit} = ${sum}`);

                num = Math.floor(num / 10);
                steps.push(`N = N DIV 10 = ${num}`);
            } while (num > 0);

            result = `La somme des chiffres de ${originalNum} est: ${sum}`;
            steps.push(`Retourne S = ${sum}`);
            steps.push('Fin de la fonction');
            break;
        }

        case 'affichage': {
            const array = getModalArrayValues();

            steps.push('Début de la procédure affichage');
            let output = '';

            for (let i = 0; i < array.length; i++) {
                steps.push(`Affichage: V[${i}] = ${array[i]}`);
                output += `V[${i}] = ${array[i]}<br>`;
            }

            result = output;
            steps.push('Fin de la procédure');
            break;
        }

        case 'affichage_pairs': {
            const array = getModalArrayValues();

            steps.push('Début de la procédure affiche');
            let output = '';

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} mod 2 = ${array[i] % 2}`);
                if (array[i] % 2 === 0) {
                    steps.push(`t[${i}] est pair, donc affichage: T[${i}] = ${array[i]}`);
                    output += `T[${i}] = ${array[i]}<br>`;
                } else {
                    steps.push(`t[${i}] est impair, pas d'affichage`);
                }
            }

            result = output || 'Aucun élément pair dans le tableau';
            steps.push('Fin de la procédure');
            break;
        }

        case 'extraire': {
            const array = getModalArrayValues();

            steps.push('Début de la procédure extraire');
            steps.push('j = 0, k = 0');

            const evens = [];
            const odds = [];

            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si t[${i}] = ${array[i]} mod 2 = ${array[i] % 2}`);
                if (array[i] % 2 === 0) {
                    evens.push(array[i]);
                    steps.push(`t[${i}] est pair, donc Tp[${evens.length - 1}] = ${array[i]}, j = j + 1 = ${evens.length}`);
                } else {
                    odds.push(array[i]);
                    steps.push(`t[${i}] est impair, donc Timp[${odds.length - 1}] = ${array[i]}, k = k + 1 = ${odds.length}`);
                }
            }

            result = `Tableau des éléments pairs (TP): [${evens.join(', ')}]<br>Tableau des éléments impairs (Timp): [${odds.join(', ')}]`;
            steps.push(`Tableau TP de taille ${evens.length}: [${evens.join(', ')}]`);
            steps.push(`Tableau Timp de taille ${odds.length}: [${odds.join(', ')}]`);
            steps.push('Fin de la procédure');
            break;
        }

        case 'insertion': {
            const array = getModalArrayValues();
            const position = parseInt(document.getElementById('modal-insert-position').value);
            const value = parseInt(document.getElementById('modal-insert-value').value);

            if (isNaN(position) || position < 0 || position > array.length) {
                alert(`La position doit être entre 0 et ${array.length}`);
                return;
            }

            if (isNaN(value)) {
                alert('Veuillez entrer une valeur à insérer valide');
                return;
            }

            steps.push('Début de la procédure insertion');

            const result_array = [...array];
            // Push a placeholder to increase array size
            result_array.push(null);

            for (let i = result_array.length - 1; i > position; i--) {
                result_array[i] = result_array[i - 1];
                steps.push(`t[${i}] = t[${i-1}] = ${result_array[i]}`);
            }

            result_array[position] = value;
            steps.push(`t[${position}] = ${value}`);

            result = `Tableau après insertion: [${result_array.join(', ')}]`;
            steps.push('Fin de la procédure');
            break;
        }

        case 'remplir_lettresonly': {
            // Get values from the modal array inputs as strings
            const size = parseInt(document.getElementById('modal-array-size').value);
            const array = [];

            for (let i = 0; i < size; i++) {
                const element = document.getElementById(`modal-array-element-${i}`);
                if (element) {
                    array.push(element.value.toString());
                }
            }

            steps.push('Début de la procédure remplir');

            // Helper function to check if a string contains only letters
            const containsOnlyLetters = str => /^[A-Za-z]+$/.test(str);

            let allLetters = true;
            for (let i = 0; i < array.length; i++) {
                steps.push(`Vérification si verif(t[${i}]) = verif("${array[i]}")`);

                if (containsOnlyLetters(array[i])) {
                    steps.push(`"${array[i]}" ne contient que des lettres, accepté`);
                } else {
                    allLetters = false;
                    steps.push(`"${array[i]}" contient des caractères non alphabétiques, nécessite une nouvelle saisie`);
                }
            }

            result = allLetters ?
                `Tableau rempli avec des chaînes alphabétiques: [${array.join(', ')}]` :
                `Certaines valeurs contiennent des caractères non alphabétiques, veuillez refaire la saisie`;

            steps.push('Fin de la procédure');
            break;
        }

        default:
            result = `L'algorithme "${algoKey}" sera implémenté prochainement.`;
    }

    // Display results with animation
    if (result) {
        // Handle HTML content in result
        if (result.includes('<br>')) {
            resultContent.innerHTML = result;
        } else {
            resultContent.textContent = result;
        }

        executionSteps.innerHTML = steps.map(step =>
            `<div class="execution-step">${step}</div>`
        ).join('');

        // Fade in results
        resultsSection.style.opacity = '0';
        resultsSection.classList.remove('hidden');
        setTimeout(() => {
            resultsSection.style.transition = 'opacity 0.3s ease-in-out';
            resultsSection.style.opacity = '1';

            // Ensure scrolling works by setting explicit styles
            executionSteps.style.overflowY = 'auto';
            executionSteps.style.maxHeight = '400px';
            executionSteps.style.display = 'block';

            // Scroll to the top of the execution steps
            executionSteps.scrollTop = 0;

            // Ensure modal execution steps also have proper scrolling
            const modalExecutionSteps = document.getElementById('modal-execution-steps');
            if (modalExecutionSteps) {
                modalExecutionSteps.style.overflowY = 'auto';
                modalExecutionSteps.style.maxHeight = '400px';
                modalExecutionSteps.style.display = 'block';
                modalExecutionSteps.scrollTop = 0;
            }
        }, 0);
    }
}

// Initialize the application
function init() {
    fetchAlgorithms();
    setupEventListeners();

    // Add CSS for line clamping
    const style = document.createElement('style');
    style.textContent = `
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Prevent scrolling when modal is open */
        body.modal-open {
            overflow: hidden;
        }
    `;
    document.head.appendChild(style);

    // Ensure execution steps can be scrolled
    document.addEventListener('DOMContentLoaded', function() {
        const executionStepsElements = document.querySelectorAll('#execution-steps, #modal-execution-steps');
        executionStepsElements.forEach(element => {
            if (element) {
                // Make sure scroll events aren't prevented
                element.addEventListener('wheel', function(e) {
                    e.stopPropagation();
                });
            }
        });

        // Enable window scrolling when content exceeds viewport
        function checkForScroll() {
            if (document.body.scrollHeight > window.innerHeight) {
                document.documentElement.style.overflowY = 'auto';
                document.body.style.overflowY = 'auto';
            }
        }

        // Check on page load
        checkForScroll();

        // Check after results are shown
        executeButton.addEventListener('click', function() {
            // Wait for results to render
            setTimeout(checkForScroll, 500);
        });

        // Listen for window resize
        window.addEventListener('resize', checkForScroll);
    });
}

// Initialize on load
window.addEventListener('DOMContentLoaded', init);


       </script> 
</body>
</html>